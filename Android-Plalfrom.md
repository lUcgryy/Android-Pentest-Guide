<div align='center'>

# **Android Platform Overview**

</div>


## **1. Android Architecture**

![](./imgs/Android-Plalfrom/android_software_stack.png)

- **Kernel:** At the lowest level, Android is based on a variation of the Linux Kernel containing some significant additions, including Low Memory Killer, wake locks, the Binder IPC driver, etc

- **HAL:** On top of the kernel, the Hardware Abstraction Layer (HAL) defines a standard interface for interacting with built-in hardware components

- **Runtime Environment:** Android apps are written in Java and Kotlin and then compiled to Dalvik bytecode which can be then executed using a runtime that interprets the bytecode instructions and executes them on the target device. For Android, this is the Android Runtime (ART)

    ![](./imgs/Android-Plalfrom/java_vs_dalvik.png)

    Before Android 5.0 (API level 21), Android executed bytecode on the Dalvik Virtual Machine (DVM), where it was translated into machine code at execution time, a process known as just-in-time (JIT) compilation

    Since Android 5.0 (API level 21), Android executes bytecode on the Android Runtime (ART) which is the successor of the DVM. ART executes the Dalvik bytecode differently, using a hybrid combination of ahead-of-time (AOT), just-in-time (JIT) and profile-guided compilation.

    - **AOT** pre-compiles Dalvik bytecode into native code, and the generated code will be saved on disk with the .oat extension (ELF binary). AOT compilation is executed during the installation of the app. Since applications are always optimized against the current version of the OS, this means that software updates will recompile all previously compiled applications, resulting in a significant increase in the system update time. Finally, AOT compilation will compile the entire application, even if certain parts are never used by the user.
    - **Profile-guided compilation** is a hybrid approach that was introduced in Android 7 (API level 24). At first, the application will use JIT compilation, and Android keeps track of all the parts of the application that are frequently used. This information is stored in an application profile and when the device is idle, a compilation (dex2oat) daemon runs which AOT compiles the identified frequent code paths from the profile.

- **Sandboxing:** Android apps don't have direct access to hardware resources, and each app runs in its own virtual machine or sandbox. This enables the OS to have precise control over resources and memory access on the device

## **2. Android Security: Defense-in-Depth Approach**

**Device encryption**

- **Full-Disk Encryption (FDE):** Android 5.0 (API level 21) and above support full-disk encryption. This encryption uses a single key protected by the user's device password to encrypt and decrypt the user data partition

- **File-Based Encryption (FBE):** Android 7.0 (API level 24) supports file-based encryption. File-based encryption allows different files to be encrypted with different keys so they can be deciphered independently.

**Trusted Execution Environment (TEE)**

Android offers a trusted execution environment in dedicated hardware to solve the problem of securely generating and protecting cryptographic keys. Three main modules are responsible for this:

- **Hardware-backed KeyStore:** This module offers cryptographic services to the Android OS and third-party apps.
- **StrongBox:** In Android 9 (Pie), StrongBox was introduced, another approach to implement a hardware-backed KeyStore. StrongBox is an actual complete separate hardware chip that is added to the device on which the KeyStore is implemented. All the sensitive cryptographic operations happen on this chip, in the secure boundaries of StrongBox.
- **GateKeeper:** This module is responsible for authenticating the user and generating the keys that will be used to encrypt the data.

**Verified Boot**

The goal of verified boot is to establish a trust relationship between the hardware and the actual code that executes on this hardware. During the verified boot sequence, a full chain of trust is established starting from the hardware-protected Root-of-Trust (RoT) up until the final system that is running, passing through and verifying all the required boot phases.

**Software Isolation**

- **Android Users and Groups**

    In Android, the multi-user support of the Linux kernel is used to sandbox apps: with a few exceptions, each app runs as though under a separate Linux user

    The file `system/core/include/private/android_filesystem_config.h` includes a list of the predefined users and groups system processes are assigned to

    Example: 

    ```C
    #define AID_ROOT             0  /* traditional unix root user */
    #...
    #define AID_SYSTEM        1000  /* system server */
    #...
    #define AID_SHELL         2000  /* adb and debug shell user */
    #...
    #define AID_APP_START          10000  /* first app user */
    ...
    ```
- **SELinux**

    Security-Enhanced Linux (SELinux) uses a Mandatory Access Control (MAC) system to further lock down which processes should have access to which resources. Each resource is given a label in the form of `user:role:type:mls_level` which defines which users are able to execute which types of actions on it

- **Permissions**

    Android implements an extensive permissions system that is used as an access control mechanism. It ensures controlled access to sensitive user data and device resources

**Network security**

- **TLS by Default**

    Android system will only allow apps to communicate over a network channel that is established using the Transport Layer Security (TLS) protocol

- **DNS over TLS**

    It allows you to perform queries to DNS servers using the TLS protocol. A secure channel is established with the DNS server through which the DNS query is sent.

**Anti-exploitation**

- ASLR, KASLR, PIE and DEP

    - **Address Space Layout Randomization (ASLR)** is a standard protection against buffer-overflow attacks, which makes sure that both the application and the OS are loaded to random memory
    - In Android 8.0 (API level 26), this protection was also implemented for the kernel (**KASLR**)
    - ASLR protection is indicated by the Position Independent Executable (**PIE**) flag
    - **Data Execution Prevention (DEP)** prevents code execution on the stack and heap, which is also used to combat buffer-overflow exploits

- **SECCOMP Filter**

    Android has introduced the support for Secure Computing (SECCOMP) filters for all Zygote based processes (i.e. user applications). These filters restrict the available syscalls to those exposed through bionic

**Android Application Structure**

- **Communication with the Operating System**

    Android apps interact with system services via the Android Framework, an abstraction layer that offers high-level Java APIs. The majority of these services are invoked via normal Java method calls and are translated to IPC calls to system services that are running in the background

- **The App Sandbox**

    Apps are executed in the Android Application Sandbox, which separates the app data and code execution from other apps on the device.

    Installation of a new app creates a new directory named after the app package, which results in the following path: `/data/data/[package-name]`. This directory holds the app's data. Linux directory permissions are set such that the directory can be read from and written to only with the app's unique UID.

    ![](./imgs/Android-Plalfrom/Selection_003.png)

    Developers who want their apps to share a common sandbox can sidestep sandboxing. When two apps are signed with the same certificate and explicitly share the same user ID (having the sharedUserId in their AndroidManifest.xml files), each can access the other's data directory

    ```xml
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.android.nfc"
    android:sharedUserId="android.uid.nfc">
    ```
    
    - **Linux User Management**
    
        Android creates a unique UID for each Android app and runs the app in a separate process. Consequently, each app can access its own resources only. This protection is enforced by the Linux kernel.

        The relationship between group IDs and permissions is defined in the following file: `frameworks/base/data/etc/platform.xml`

        ```xml
        <permission name="android.permission.INTERNET" >
            <group gid="inet" />
        </permission>

        <permission name="android.permission.READ_LOGS" >
            <group gid="log" />
        </permission>

        <permission name="android.permission.WRITE_MEDIA_STORAGE" >
            <group gid="media_rw" />
            <group gid="sdcard_rw" />
        </permission>
        ```

    - **Zygote**

        The process Zygote starts up during Android initialization. Zygote is a system service for launching apps. The Zygote process is a "base" process that contains all the core libraries the app needs

    - **App Lifecycle**

    In general, processes can be in one of four states: a foreground process, a visible process, a service process, a cached process

- **App Bundles**

    Android applications can be shipped in two forms: the Android Package Kit (APK) file or an Android App Bundle (.aab). Android App Bundles provide all the resources necessary for an app, but defer the generation of the APK and its signing to Google Play.

    Use the `bundletool` command line tool from Google to build unsigned APKs in order to use the existing tooling on the APK

    ```zsh
    bundletool build-apks --bundle=/MyApp/my_app.aab --output=/MyApp/my_app.apks
    ```
- **Android Manifest**

    The manifest file describes the app structure, its components (activities, services, content providers, and intent receivers), and requested permissions. It also contains general app metadata, such as the app's icon, version number, and theme.

**App components**

- **Activities**

    Activities make up the visible part of any app. There is one activity per screen. They contain all user interface elements: fragments, views, and layouts.

- **Fragment**

    A fragment represents a behavior or a portion of the user interface within the activity

    ![](./imgs/Android-Plalfrom/fragment.png)

- **Content Providers**

    Android uses SQLite to store data permanently. By default, a database belonging to a given app is accessible to this app only

    Content providers offer a great mechanism for abstracting data sources; they also provide a standard and efficient mechanism to share data between apps, including native apps. To be accessible to other apps, a content provider needs to be explicitly declared in the manifest file of the app that will share it.

    Content providers are implemented through a URI addressing scheme: they all use the content:// model. Content providers offer all regular database operations: create, read, update, delete
    
- **Services**

    Services are Android OS components (based on the Service class) that perform tasks in the background

- **Inter-Process Communication**

    Inter-process communication facilities allow apps to exchange signals and data securely

    To use IPC, apps call IPC methods in proxy objects. The proxy objects transparently marshall the call parameters into a parcel and send a transaction to the Binder server, which is implemented as a character driver. The server holds a thread pool for handling incoming requests and delivers messages to the destination object.

    ![](./imgs/Android-Plalfrom/binder.jpg)

- **Intent**

    An Intent is a messaging object that can be used to request an action from another app component. There are three fundamental use cases: Starting an activity, Starting a service, and Delivering a broadcast.

    There are two types of intents. Explicit intents name the component that will be started (the fully qualified class name)

    ```Java
    Intent intent = new Intent(this, myActivity.myClass);
    ```

    Implicit intents are sent to the OS to perform a given action on a given set of data. It is up to the system to decide which app or class will perform the corresponding service 

    ```Java
    Intent intent = new Intent(Intent.MY_ACTION, Uri.parse("https://www.owasp.org"));
    ```

    Android uses intents to broadcast messages to apps (such as an incoming call or SMS) important power supply information (low battery, for example), and network changes (loss of connection, for instance). Extra data may be added to intents

- **Broadcast Receivers**

    Broadcast Receivers are components that allow apps to receive notifications from other apps and from the system itself. With them, apps can react to events (internal, initiated by other apps, or initiated by the operating system). They are generally used to update user interfaces, start services, update content, and create user notifications.

**Android Application Publishing**

When publish the apps, they must be first signed. It identifies the app’s author and ensures that the app has not been modified since its initial distribution.

- **Signing Process**

    During development, apps are signed with an automatically generated certificate. Most stores don't accept this kind of certificate for publishing; therefore, a certificate with more secure features must be created. When an application is installed on the Android device, the Package Manager ensures that it has been signed with the certificate included in the corresponding APK.

- **APK Signing Schemes**

    - **JAR Signing (v1 Scheme)**

    The original version of app signing implements the signed APK as a standard signed JAR, which must contain all the entries in META-INF/MANIFEST.MF. All files must be signed with a common certificate

    - **APK Signature Scheme (v2 Scheme)**

    With the APK signature scheme, the complete APK is hashed and signed, and an APK Signing Block is created and inserted into the APK. During validation, the v2 scheme checks the signatures of the entire APK file

    - **APK Signature Scheme v3 (v3 Scheme)**

    V3 adds information about the supported SDK versions and a proof-of-rotation struct to the APK signing block

    - **APK Signature Scheme v4 (v4 Scheme)**

    The APK Signature Scheme v4 was introduced along with Android 11 (API level 30) and requires all devices launched with Android 11 and up to have fs-verity enabled by default

- **Creating your Certificate**

    ```zsh
    keytool -genkey -alias myDomain -keyalg RSA -keysize 2048 -validity 7300 -keystore myKeyStore.jks -storepass myStrongPassword
    ```

- **Signing an Application**

    ```zsh
    apksigner sign --out mySignedApp.apk --ks myKeyStore.jks myUnsignedApp.apk
    ```
