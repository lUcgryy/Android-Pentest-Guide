<div align='center'>

# **Data Storage Checklist**

</div>

## **1. Testing Local Storage for Sensitive Data**

**Statics Analysis**

- [ ] Check `AndroidManifest.xml` for read/write external storage permissions
- [ ] Check the source code for keywords and API calls that are used to store data
    - [ ] File Permission: `MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE`
    - [ ] Classes and functions: `SharedPreferences` (class), `FileOutPutStream` (class), `getExternal*` (function), `getWritableDatabase` (function), `getReadableDatabase` (function), `getCacheDir` (function), `getExternalCacheDirs` (function)
- [ ] Look for hardcoded sensitive data in the source code. For example

```java
this.db = localUserSecretStore.getWritableDatabase("SuperPassword123");
```

- [ ] Look for common location of secrets: 

- res/values/strings.xml
- build configs, such as in local.properties or gradle.properties
- /data/misc/keystore/

**Dynamic Analysis**

Install and use the app, executing all functions at least once. Data can be generated when entered by the user, sent by the endpoint, or shipped with the app. Then complete the following:

- [ ] Check both internal and external local storage for any files created by the application that contain sensitive data.
- [ ] Identify development files, backup files, and old files that shouldn't be included with a production release.
- [ ] Determine whether SQLite databases are available and whether they contain sensitive information. SQLite databases are stored in /data/data/<package-name>/databases.
- [ ] Identify if SQLite databases are encrypted. If so, determine how the database password is generated and stored and if this is sufficiently protected as described in the "Storing a Key" section of the Keystore overview.
- [ ] Check Shared Preferences that are stored as XML files (in /data/data/<package-name>/shared_prefs) for sensitive information. Shared Preferences are insecure and unencrypted by default. Some apps might opt to use secure-preferences to encrypt the values stored in Shared Preferences.
- [ ] Check the permissions of the files in /data/data/<package-name>. Only the user and group created when you installed the app (e.g., u0_a82) should have user read, write, and execute permissions (rwx). Other users should not have permission to access files, but they may have execute permissions for directories.
- [ ] Check for the usage of any Firebase Real-time databases and attempt to identify if they are misconfigured by making the following network call: https://_firebaseProjectName_.firebaseio.com/.json
- [ ] Determine whether a Realm database is available in /data/data/<package-name>/files/, whether it is unencrypted, and whether it contains sensitive information. By default, the file extension is realm and the file name is default. Inspect the Realm database with the Realm Browser.

## **2. Testing Local Storage for Input Validation**

The data needs to be validated the moment it is read from the storage mechanism.

## **3. Testing Logs for Sensitive Data**

**Static Analysis**

Functions and classes, such as:
- [ ] android.util.Log
- [ ] Log.d | Log.e | Log.i | Log.v | Log.w | Log.wtf
- [ ] Logger

Keywords and system output:

- [ ] System.out.print | System.err.print
- [ ] logfile
- [ ] logging
- [ ] logs

**Dynamic Analysis**

Use all the mobile app functions at least once, then identify the application's data directory and look for log files (/data/data/<package-name>). Check the application logs to determine whether log data has been generated; some mobile applications create and store their own logs in the data directory.

## **4. Determining Whether Sensitive Data Is Shared with Third Parties via Embedded Services**


**Static Analysis**

Review the third party's source code, requested permissions and check for any known vulnerabilities

All data that's sent to third-party services should be anonymized. No other data (such as IDs that can be mapped to a user account or session) should be sent to a third party.

**Dynamic Analysis**

Intercept all requests to external services for embedded sensitive information. All app requests that aren't sent directly to the server on which the main function is hosted should be checked for sensitive information.

## **5. Determining Whether Sensitive Data Is Shared with Third Parties via Notifications**

**Static Analysis**

Search for any usage of the NotificationManager class 

**Dynamic Analysis**

Run the application and start tracing all calls to functions related to the notifications creation, e.g. setContentTitle or setContentText from NotificationCompat.Builder. Observe the trace in the end and evaluate if it contains any sensitive information which another app might have eavesdropped.

## **6. Determining Whether the Keyboard Cache Is Disabled for Text Input Fields**

**Static Analysis**

In the layout definition of an activity, looking for the value of the `android:inputType`. If the value is set to `textNoSuggestions`, `textPassword`, `textVisiblePassword`, `numberPassword`, `textWebPassword`, the keyboard cache is disabled.

Check the application code to verify that none of the input types are being overwritten

Check the minimum required SDK version in the Android Manifest (`android:minSdkVersion`)

**Dynamic Analysis**

Start the app and click in the input fields that take sensitive data. If strings are suggested, the keyboard cache has not been disabled for these fields.

## **7. Determining Whether Sensitive Stored Data Has Been Exposed via IPC Mechanisms**

**Static Analysis**

Look at AndroidManifest.xml to detect content providers exposed by the app (`<provider>` element.)

- [ ] Determine whether the value of the export tag (`android:exported`) is `"true"`
- [ ] Determine whether the data is being protected by a permission tag (`android:permission`)
- [ ] Determine whether the `android:protectionLevel` attribute has the value `signature`

Inspect the source code to understand how the content provider is meant to be used. Search for the following keywords:

- [ ] android.content.ContentProvider
- [ ] android.database.Cursor
- [ ] android.database.sqlite
- [ ] .query
- [ ] .update
- [ ] .delete

**Dynamic Analysis**

Testing Content Providers

- Use Drozer to enumerate the content providers exposed by the app: `run app.provider.info -a <app-package-name>`

- Use Drozer to identify content providers URIs: `run scanner.provider.finduris -a <app-package-name>` 

- Use Drozer to extract data from content providers: `run app.provider.query <content-provider-uri> --vertical`

- Use Drozer to test for SQL injection:

    ```zsh
    run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection "'"
    unrecognized token: "' FROM Passwords" (code 1): , while compiling: SELECT ' FROM Passwords
    ```

- Use Drozer to test for Directory Traversal: `run scanner.provider.traversal -a <app-package-name>`

## **8. Checking for Sensitive Data Disclosure Through the User Interface**

**Static Analysis**

Text Fields

- Check for the following attribute in the definition of EditText

    ```
    android:inputType="textPassword"
    ```

App Notifications

- Search for any usage of the `NotificationManager` class.

**Dynamic Analysis**

Text Fields

- If the information is masked by, for example, replacing input with asterisks or dots, the app isn't leaking data to the user interface.

App Notifications

- Looking for ways to trigger any notifications.

- Start tracing all calls to functions related to the notifications creation. Observe the trace in the end and evaluate if it contains any sensitive information.

## **9. Testing Backups for Sensitive Data**

**Static Analysis**

Local

- Check the AndroidManifest.xml file for the following flag: `android:allowBackup="true"`

Cloud

Determine the following

- [ ] which files are sent to the cloud (e.g., SharedPreferences)
- [ ] whether the files contain sensitive information
- [ ] whether sensitive information is encrypted before being sent to the cloud.

**Dynamic Analysis**

- Use asb to backup the app's data: `adb backup -f <backup-file-name> -noapk <app-package-name>`

- After the backup process is finished, the file .ab will be in your working directory. Run the following command to convert the .ab file to tar.

    ```
    dd if=mybackup.ab bs=24 skip=1|openssl zlib -d > mybackup.tar
    ```

- Extract the tar file to your working directory.

    ```
    tar xvf mybackup.tar
    ```

## **10. Finding Sensitive Information in Auto-Generated Screenshots**

**Static Analysis**

- [ ] Find out whether the FLAG_SECURE option has been set. Example:

```java
getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE,
                WindowManager.LayoutParams.FLAG_SECURE);

setContentView(R.layout.activity_main);
```

**Dynamic Analysis**

- Navigate to any screen that contains sensitive information and click the home button to send the app to the background, then press the app switcher button to see the snapshot. As shown below, if FLAG_SECURE is set (left image), the snapshot will be empty; if the flag has not been set (right image), activity information will be shown:

    ![](./imgs/Android-Plalfrom/1.png)

- On devices supporting file-based encryption (FBE), snapshots are stored in the /data/system_ce/<USER_ID>/<IMAGE_FOLDER_NAME> folder. <IMAGE_FOLDER_NAME> depends on the vendor but most common names are snapshots and recent_images. If the device doesn't support FBE, the /data/system/<IMAGE_FOLDER_NAME> folder is used.

## **11. Testing Memory for Sensitive Data**

**Static Analysis**

- [ ] Try to identify application components and map where data is used.
- [ ] Make sure that sensitive data is handled by as few components as possible.
- [ ] Make sure that object references are properly removed once the object containing the sensitive data is no longer needed.
- [ ] Make sure that garbage collection is requested after references have been removed.
- [ ] Make sure that sensitive data gets overwritten as soon as it is no longer needed.
- [ ] Don't represent such data with immutable data types (such as String and BigInteger).
- [ ] Avoid non-primitive data types (such as StringBuilder).
- [ ] Overwrite references before removing them, outside the finalize method.
- [ ] Pay attention to third-party components (libraries and frameworks). Public APIs are good indicators.

**Dynamic Analysis**

Retrieving and Analyzing a Memory Dump

```
python3 fridump.py -U  <app-package-name> -s
```

You'll get a collection of *.data files inside the dump folder. When you add the -s flag, all strings are extracted from the dumped raw memory files and added to the file `strings.txt`

Runtime Memory Analysis

- Use [r2frida](https://github.com/nowsecure/r2frida/blob/master/README.md#installation) to analyze and inspect the app's memory while it's running

Explicitly Dumping and Analyzing the Java Heap

- Android Studio: [Memory Profiler](https://developer.android.com/studio/profile/memory-profiler)

## **12. Testing the Device-Access-Security Policy**